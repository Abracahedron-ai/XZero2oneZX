"""
Asset Bus for Hot-Swapping 3D Assets

Manages loading, swapping, and hot-reloading of 3D assets generated by TRELLIS
or loaded from other sources. Integrates with the compositor and behavior brain.
"""

import asyncio
from typing import Dict, Optional, Any, List
from dataclasses import dataclass
from datetime import datetime
from pathlib import Path
import json
import logging
import threading

logger = logging.getLogger(__name__)


@dataclass
class AssetEntry:
    """Entry in asset registry."""
    asset_id: str
    asset_path: str
    format: str  # 'mesh', '3dgs', 'nerf', 'radiance_field'
    asset_type: str  # 'prop', 'character', 'environment'
    metadata: Dict[str, Any]
    loaded: bool = False
    loaded_at: Optional[datetime] = None
    usage_count: int = 0


class AssetBus:
    """
    Asset Bus for managing 3D assets.
    
    Handles:
    - Asset registration and discovery
    - Hot-swapping assets at runtime
    - Asset format conversion
    - Integration with compositor
    """
    
    def __init__(self, asset_dir: Optional[Path] = None):
        """
        Initialize asset bus.
        
        Args:
            asset_dir: Directory containing assets
        """
        self.asset_dir = Path(asset_dir) if asset_dir else Path("assets/models/generated")
        self.asset_dir.mkdir(parents=True, exist_ok=True)
        
        # Asset registry
        self.assets: Dict[str, AssetEntry] = {}
        self.loaded_assets: Dict[str, Any] = {}  # In-memory loaded assets
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Asset watcher for hot-reloading
        self.watching = False
        self.watcher_thread: Optional[threading.Thread] = None
        
        logger.info(f"Asset bus initialized: {self.asset_dir}")
    
    def register_asset(
        self,
        asset_id: str,
        asset_path: str,
        format: str,
        asset_type: str = "prop",
        metadata: Optional[Dict] = None
    ) -> AssetEntry:
        """
        Register a new asset.
        
        Args:
            asset_id: Unique identifier for the asset
            asset_path: Path to asset file
            format: Asset format ('mesh', '3dgs', 'nerf', etc.)
            asset_type: Type of asset ('prop', 'character', 'environment')
            metadata: Additional metadata
            
        Returns:
            AssetEntry for the registered asset
        """
        with self.lock:
            entry = AssetEntry(
                asset_id=asset_id,
                asset_path=str(asset_path),
                format=format,
                asset_type=asset_type,
                metadata=metadata or {},
                loaded=False
            )
            
            self.assets[asset_id] = entry
            logger.info(f"Registered asset: {asset_id} ({format})")
            
            return entry
    
    def load_asset(self, asset_id: str) -> Optional[Any]:
        """
        Load an asset into memory.
        
        Args:
            asset_id: Asset identifier
            
        Returns:
            Loaded asset object or None if not found
        """
        if asset_id not in self.assets:
            logger.warning(f"Asset not found: {asset_id}")
            return None
        
        # Check if already loaded
        if asset_id in self.loaded_assets:
            self.assets[asset_id].usage_count += 1
            return self.loaded_assets[asset_id]
        
        entry = self.assets[asset_id]
        asset_path = Path(entry.asset_path)
        
        if not asset_path.exists():
            logger.error(f"Asset file not found: {asset_path}")
            return None
        
        try:
            # Load asset based on format
            asset = self._load_asset_by_format(asset_path, entry.format)
            
            if asset:
                with self.lock:
                    self.loaded_assets[asset_id] = asset
                    entry.loaded = True
                    entry.loaded_at = datetime.now()
                    entry.usage_count = 1
                
                logger.info(f"Loaded asset: {asset_id}")
                return asset
            
        except Exception as e:
            logger.error(f"Error loading asset {asset_id}: {e}")
            return None
    
    def _load_asset_by_format(self, asset_path: Path, format: str) -> Optional[Any]:
        """Load asset based on format."""
        # Placeholder implementations - actual loading depends on format
        if format == "mesh":
            # Load mesh (OBJ, PLY, etc.)
            # return load_mesh(asset_path)
            return {"type": "mesh", "path": str(asset_path)}
        
        elif format == "3dgs":
            # Load 3D Gaussians
            # return load_3dgs(asset_path)
            return {"type": "3dgs", "path": str(asset_path)}
        
        elif format in ["nerf", "radiance_field"]:
            # Load radiance field
            # return load_nerf(asset_path)
            return {"type": "radiance_field", "path": str(asset_path)}
        
        else:
            logger.warning(f"Unknown format: {format}")
            return None
    
    def hot_swap_asset(
        self,
        old_asset_id: str,
        new_asset_id: str
    ) -> bool:
        """
        Hot-swap an asset at runtime.
        
        Args:
            old_asset_id: Asset to replace
            new_asset_id: New asset to load
            
        Returns:
            True if swap successful
        """
        if old_asset_id not in self.assets:
            logger.warning(f"Old asset not found: {old_asset_id}")
            return False
        
        if new_asset_id not in self.assets:
            logger.warning(f"New asset not found: {new_asset_id}")
            return False
        
        try:
            # Load new asset
            new_asset = self.load_asset(new_asset_id)
            
            if new_asset:
                # Replace in loaded assets
                with self.lock:
                    if old_asset_id in self.loaded_assets:
                        del self.loaded_assets[old_asset_id]
                    
                    self.loaded_assets[new_asset_id] = new_asset
                    self.assets[old_asset_id].loaded = False
                    self.assets[new_asset_id].loaded = True
                
                logger.info(f"Hot-swapped asset: {old_asset_id} -> {new_asset_id}")
                return True
            
        except Exception as e:
            logger.error(f"Error hot-swapping assets: {e}")
            return False
    
    def unload_asset(self, asset_id: str):
        """Unload an asset from memory."""
        with self.lock:
            if asset_id in self.loaded_assets:
                del self.loaded_assets[asset_id]
                if asset_id in self.assets:
                    self.assets[asset_id].loaded = False
                logger.info(f"Unloaded asset: {asset_id}")
    
    def get_asset(self, asset_id: str) -> Optional[AssetEntry]:
        """Get asset entry."""
        return self.assets.get(asset_id)
    
    def list_assets(self, asset_type: Optional[str] = None) -> List[AssetEntry]:
        """List all assets, optionally filtered by type."""
        assets = list(self.assets.values())
        if asset_type:
            assets = [a for a in assets if a.asset_type == asset_type]
        return assets
    
    def discover_assets(self):
        """Discover assets in asset directory."""
        logger.info("Discovering assets...")
        
        for asset_dir in self.asset_dir.iterdir():
            if not asset_dir.is_dir():
                continue
            
            metadata_path = asset_dir / "metadata.json"
            if not metadata_path.exists():
                continue
            
            try:
                with open(metadata_path, 'r') as f:
                    metadata = json.load(f)
                
                asset_id = metadata.get("asset_name", asset_dir.name)
                asset_path = metadata.get("asset_path", "")
                format = metadata.get("format", "mesh")
                
                self.register_asset(
                    asset_id=asset_id,
                    asset_path=asset_path or str(asset_dir),
                    format=format,
                    asset_type=metadata.get("asset_type", "prop"),
                    metadata=metadata
                )
                
            except Exception as e:
                logger.warning(f"Error discovering asset in {asset_dir}: {e}")


# Global asset bus instance
_bus_instance: Optional[AssetBus] = None


def get_asset_bus() -> AssetBus:
    """Get global asset bus instance."""
    global _bus_instance
    if _bus_instance is None:
        _bus_instance = AssetBus()
        _bus_instance.discover_assets()
    return _bus_instance


def reset_bus():
    """Reset global asset bus instance."""
    global _bus_instance
    _bus_instance = None


